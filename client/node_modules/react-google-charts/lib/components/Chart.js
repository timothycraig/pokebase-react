'use strict';

exports.__esModule = true;
exports.default = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

var _DEFAULT_CHART_COLORS = require('../constants/DEFAULT_CHART_COLORS');

var _DEFAULT_CHART_COLORS2 = _interopRequireDefault(_DEFAULT_CHART_COLORS);

var _GoogleChartLoader = require('./GoogleChartLoader');

var _GoogleChartLoader2 = _interopRequireDefault(_GoogleChartLoader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var debug = require('debug')('react-google-charts:Chart');


var uniqueID = 0;

var generateUniqueID = function generateUniqueID() {
  uniqueID++;
  return "reactgooglegraph-" + uniqueID;
};

var googleErrorHandler = function googleErrorHandler(id, message) {
  console.error("Google Charts encountered an error : ");
  console.error('Error ID : ' + id);
  console.error('Error MESSAGE : ' + message);
};

var Chart = function (_React$Component) {
  _inherits(Chart, _React$Component);

  function Chart(props) {
    _classCallCheck(this, Chart);

    debug('constructor', props);

    var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

    _this.state = { graphID: props.graph_id || generateUniqueID() };
    _this.chart = null;
    _this.wrapper = null;
    _this.hidden_columns = {};
    _this.dataTable = [];
    return _this;
  }

  Chart.prototype.componentDidMount = function componentDidMount() {
    var _this2 = this;

    debug('componentDidMount');
    if (this.props.loadCharts) {
      _GoogleChartLoader2.default.init(this.props.chartPackages, this.props.chartVersion).then(function (asd) {
        _this2.drawChart();
      });
    } else {
      this.drawChart();
    }
  };

  Chart.prototype.componentWillUnmount = function componentWillUnmount() {
    try {
      google.visualization.events.removeAllListeners(this.wrapper);
    } catch (err) {
      console.error("Error removing events, error : ", err);
    }
  };

  Chart.prototype.componentDidUpdate = function componentDidUpdate() {
    var _this3 = this;

    debug('componentDidUpdate');
    if (!this.props.loadCharts) {
      this.drawChart();
    } else if (_GoogleChartLoader2.default.isLoading) {
      _GoogleChartLoader2.default.initPromise.then(function () {
        _this3.drawChart.bind(_this3)();
      });
    } else if (_GoogleChartLoader2.default.isLoaded) {
      this.drawChart.bind(this)();
    }
  };

  Chart.prototype.buildDataTableFromProps = function buildDataTableFromProps() {
    debug('buildDataTableFromProps', this.props);
    if (this.props.data === null && this.props.rows.length === 0) {
      throw new Error("Can't build DataTable from rows and columns: rows array in props is empty");
    } else if (this.props.data === null && this.props.columns.length === 0) {
      throw new Error("Can't build DataTable from rows and columns: columns array in props is empty");
    }
    if (this.props.data !== null) {
      try {
        this.wrapper.setDataTable(this.props.data);
        var _dataTable = this.wrapper.getDataTable();
        return _dataTable;
      } catch (err) {
        console.log('Failed to set DataTable from data props ! ', err);
        throw new Error('Failed to set DataTable from data props ! ', err);
      }
    }

    var dataTable = new google.visualization.DataTable();
    this.props.columns.forEach(function (column) {
      dataTable.addColumn(column);
    });
    dataTable.addRows(this.props.rows);
    return dataTable;
  };

  Chart.prototype.updateDataTable = function updateDataTable() {
    debug("updateDataTable");
    google.visualization.errors.removeAll(document.getElementById(this.wrapper.getContainerId()));
    this.dataTable.removeRows(0, this.dataTable.getNumberOfRows());
    this.dataTable.removeColumns(0, this.dataTable.getNumberOfColumns());
    this.dataTable = this.buildDataTableFromProps.bind(this)();
    return this.dataTable;
  };
  //DEPRECATED AND NOT USED


  Chart.prototype.getDataTableFromProps = function getDataTableFromProps() {
    debug("getDataTableFromProps");
    return this.props.data !== null ? this.props.data : this.buildDataTableFromProps.bind(this)();
  };

  Chart.prototype.drawChart = function drawChart() {
    var _this4 = this;

    debug("drawChart", this);
    if (!this.wrapper) {
      var chartConfig = {
        chartType: this.props.chartType,
        options: this.props.options,
        containerId: this.state.graphID
      };
      this.wrapper = new google.visualization.ChartWrapper(chartConfig);
      this.dataTable = this.buildDataTableFromProps.bind(this)();
      this.wrapper.setDataTable(this.dataTable);

      google.visualization.events.addOneTimeListener(this.wrapper, 'ready', function () {
        _this4.chart = _this4.wrapper.getChart();
        _this4.listenToChartEvents.bind(_this4)();
        _this4.addChartActions.bind(_this4)();
      });
    } else {
      this.updateDataTable.bind(this)();
      this.wrapper.setDataTable(this.dataTable);
      this.wrapper.setChartType(this.props.chartType);
      this.wrapper.setOptions(this.props.options);
    }
    this.wrapper.draw();
  };

  Chart.prototype.addChartActions = function addChartActions() {
    debug('addChartActions', this.props.chartActions);
    if (this.props.chartActions === null) {
      return;
    }
    this.chart.setAction({
      id: this.props.chartActions.id,
      text: this.props.chartActions.text,
      action: this.props.chartActions.action.bind(this, this.chart)
    });
  };

  Chart.prototype.listenToChartEvents = function listenToChartEvents() {
    var _this5 = this;

    debug('listenToChartEvents', this.props.legend_toggle, this.props.chartEvents);
    if (this.props.legend_toggle) {
      google.visualization.events.addListener(this.wrapper, 'select', this.onSelectToggle.bind(this));
    }
    this.props.chartEvents.forEach(function (chartEvent) {
      if (chartEvent.eventName === 'ready') {
        chartEvent.callback(_this5);
      } else {
        (function (chartEvent) {
          google.visualization.events.addListener(_this5.chart, chartEvent.eventName, function (e) {
            chartEvent.callback(_this5, e);
          });
        })(chartEvent);
      }
    });
  };

  Chart.prototype.onSelectToggle = function onSelectToggle() {
    debug('onSelectToggle');
    var selection = this.chart.getSelection();
    if (selection.length > 0) {
      if (selection[0].row == null) {
        var column = selection[0].column;
        this.togglePoints.bind(this)(column);
      }
    }
  };

  Chart.prototype.getColumnColor = function getColumnColor(columnIndex) {
    if (this.props.options.colors) {
      if (this.props.options.colors[columnIndex]) {
        return this.props.options.colors[columnIndex];
      }
    } else {
      if (_typeof(_DEFAULT_CHART_COLORS2.default[columnIndex]) !== undefined) {
        return _DEFAULT_CHART_COLORS2.default[columnIndex];
      } else {
        return _DEFAULT_CHART_COLORS2.default[0];
      }
    }
  };

  Chart.prototype.buildColumnFromSourceData = function buildColumnFromSourceData(columnIndex) {
    debug('buildColumnFromSourceData', columnIndex);
    return {
      label: this.dataTable.getColumnLabel(columnIndex),
      type: this.dataTable.getColumnType(columnIndex),
      sourceColumn: columnIndex
    };
  };

  Chart.prototype.buildEmptyColumnFromSourceData = function buildEmptyColumnFromSourceData(columnIndex) {
    debug('buildEmptyColumnFromSourceData', columnIndex);
    return {
      label: this.dataTable.getColumnLabel(columnIndex),
      type: this.dataTable.getColumnType(columnIndex),
      calc: function calc() {
        return null;
      }
    };
  };

  Chart.prototype.addEmptyColumnTo = function addEmptyColumnTo(columns, columnIndex) {
    debug('addEmptyColumnTo', columns, columnIndex);
    var emptyColumn = this.buildEmptyColumnFromSourceData(columnIndex);
    columns.push(emptyColumn);
  };

  Chart.prototype.hideColumn = function hideColumn(colors, columnIndex) {
    debug('hideColumn', colors, columnIndex);
    if (!this.isHidden(columnIndex)) {
      this.hidden_columns[columnIndex] = { color: this.getColumnColor(columnIndex - 1) };
    }
    colors.push('#CCCCCC');
  };

  Chart.prototype.addSourceColumnTo = function addSourceColumnTo(columns, columnIndex) {
    debug('addSourceColumnTo', columns, columnIndex);
    var sourceColumn = this.buildColumnFromSourceData(columnIndex);
    columns.push(sourceColumn);
  };

  Chart.prototype.isHidden = function isHidden(columnIndex) {
    return this.hidden_columns[columnIndex] !== undefined;
  };

  Chart.prototype.restoreColorTo = function restoreColorTo(colors, columnIndex) {
    debug('restoreColorTo', colors, columnIndex);
    debug('hidden_columns', this.hidden_columns);
    var previousColor = void 0;
    if (this.isHidden(columnIndex)) {
      previousColor = this.hidden_columns[columnIndex].color;
      delete this.hidden_columns[columnIndex];
    } else {
      previousColor = this.getColumnColor(columnIndex - 1);
    }
    if (columnIndex !== 0) {
      colors.push(previousColor);
    }
  };

  Chart.prototype.togglePoints = function togglePoints(column) {
    debug('togglePoints', column);
    var view = new google.visualization.DataView(this.wrapper.getDataTable());
    var columnCount = view.getNumberOfColumns();
    var colors = [];
    var columns = [];
    for (var i = 0; i < columnCount; i++) {
      // If user clicked on legend
      if (i === 0) {
        this.addSourceColumnTo.bind(this)(columns, i);
      } else if (i === column) {
        if (this.isHidden(i)) {
          this.addSourceColumnTo.bind(this)(columns, i);
          this.restoreColorTo.bind(this)(colors, i);
        } else {
          this.addEmptyColumnTo.bind(this)(columns, i);
          this.hideColumn.bind(this)(colors, i);
        }
      } else {
        if (this.isHidden(i)) {
          this.addEmptyColumnTo.bind(this)(columns, i);
          this.hideColumn.bind(this)(colors, i);
        } else {
          this.addSourceColumnTo.bind(this)(columns, i);
          this.restoreColorTo.bind(this)(colors, i);
        }
      }
    }
    view.setColumns(columns);
    this.props.options.colors = colors;
    this.chart.draw(view, this.props.options);
  };

  Chart.prototype.render = function render() {
    debug('render', this.props, this.state);
    var divStyle = { height: this.props.height || this.props.options.height, width: this.props.width || this.props.options.width };
    return _react2.default.createElement(
      'div',
      { id: this.state.graphID, style: divStyle },
      ' ',
      this.props.loader ? this.props.loader : 'Rendering Chart...',
      ' '
    );
  };

  return Chart;
}(_react2.default.Component);

exports.default = Chart;
;

Chart.defaultProps = {
  chartType: 'LineChart',
  rows: [],
  columns: [],
  options: {
    chart: {
      title: 'Chart Title',
      subtitle: 'Subtitle'
    },
    hAxis: { title: 'X Label' },
    vAxis: { title: 'Y Label' },
    width: '400px',
    height: '300px'
  },
  width: '400px',
  height: '300px',
  chartEvents: [],
  chartActions: null,
  data: null,
  onSelect: null,
  legend_toggle: false,
  loadCharts: true,
  loader: _react2.default.createElement(
    'div',
    null,
    'Rendering Chart'
  )
};
module.exports = exports['default'];